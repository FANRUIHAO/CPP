* 声明A类的函数f()为友元函数的操作：
	**friend void A::f();**
* 返回查找到的字符串所在主串的位置的方法：
	**indexOf()**
* 设置填充字符的函数：
	**setfill(char)**
* cpp的多态性分为**编译时的多态性和运行时的多态性**
* cout<<str.substr(5，3)指的是**输出变量str的下标为5开始之后三个字符**
* setw()用于**设置输出的宽度**
	* 例如：
		* int m=22
		* cout<<setw(5)<<m;
	* 输出结果为：   22
	* (22前面空三个间距)
* strcpy 函数的作用是**将第二个参数指向的字符串复制到第一个参数指向的内存位置。**
* strcat 函数的作用是**将第二个参数指向的字符串追加到第一个参数指向的字符串的末尾。**
* main函数里每次新建对象时先调用**基类构造函数然**后再调用**继承类构造函数**，等待所有代码运行完后**依次调用继承类的析构函数和基类的析构函数**
* "\n"等价于**endl**
_* 拷贝构造函数的函数名必须**与类名相同**，并且参数类型必须是**类名的引用**_
* operator 关键字用于**定义或重载运算符**。运算符重载允许用户为自定义类型（如类或结构体）定义特定的运算符行为，使其能够像内置类型一样使用运算符。
* 由cpp源程序文件编译而成的目标代码文件的缺省扩展名为  **obj**
* cpp基本数据类型：
  * **整型、浮点型、字符型、布尔类型**
* cpp构造类型
  * **枚举型，数组行，结构体类型，共用体类型，类类型**
* 前缀Ox是用于**标识十六进制前缀或后缀**
* 当一个或两个操作数是浮点数时，结果是**一个浮点数**
* #include指令有两种形式
  * #include <file>：这种形式用于包含**标准库头文件或系统头文件**
  * #include "file"：这种形式用于包含**用户自定义的头文件**
* 引用格式 **int &a = b;**
  * a是b的引用，a和b指向同一个地址，a的值改变b的值**也会改变**
* 函数原型的参数部分可以只包含**参数类型**，而不需要包含**参数名称**
* 形参是实参的副本，**形参的改变不会影响实参**
* 可以声明为内联函数的函数包括：**构造函数、析构函数、成员函数**
* 包含**循环语句**的函数不能声明为内联函数
* 函数声明时，必须要声明**函数名、函数类型、参数名、参数类型**
* 设置参数默认值时，先设置右边的参数默认值，再设置左边的参数默认值
* 默认参数必须放在参数序列的后部，也就是右侧
* 重载函数的参数列表必须不同，参数个数不同或者参数类型不同
* 定义模板中使用的参数类型标识符需要使用符号<>括起来
* 类中定义的成员，其隐含访问权限是private
* cpp允许在结构中定义的函数称为  成员函数
* 使用delete删除对象数组时，数组中各元素都调用析构函数
* 在类中，如果不做特别说明，所有的成员函数均为 private
* 面向对象关键要素：封装、继承、多态、抽象
* 类的常成员函数表示法：void fun() const;
* 如果没有使用private关键字定义类的数据成员，那么默认为private
* this指针存在的目的是：保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码
* 构造函数有且只有一个
* 构造函数不必指定类型说明
* 拷贝构造函数的参数是某个对象的引用名
* 析构函数不能指定返回类型
* 静态数据成员是类的所有对象共享的数据成员
  * 静态数据成员是所有对象共享的，这意味着无论创建多少个类的对象，它们都共享同一个静态数据成员。对静态数据成员的任何操作都会影响所有对象，因为它们都引用同一个变量
* 初始化类的静态整型成员的语法格式：
  * int A::x = 0;
* 任何类或者函数都可以作为友元
* 友元不是本类的成员函数，但是可以访问本类的私有成员
* 如果类A被说明成类B的友元，那么类B不一定是类A的友元
* 继承的机制是定义新类    可以使用现有类的所有成员，而不需要重新编写这些成员
* 基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以访问这些成员
* 在公有继承种，基类中的**保护成员**作为派生类的**保护成员**，基类中的**公有成员**作为派生类的**公有成员**
* **构造函数**不能被派生类继承
* 在**public、protected、private**派生方式中，派生类可以访问基类中的protected成员
* 继承中，派生类拥有的基类个数最少要有一个。
  * 派生类可以继承多个基类，这种继承方式称为**多重继承**
* 私有派生时，基类的所有成员访问权限在派生类中都是**私有的**
* 如果一个类至少有一个纯虚函数，那么就称该类为**抽象类**
* 设置虚基类（virtual）的目的是为了解决多重继承时的二义性问题
  * 虚基类可以使得共同的基类在派生类中只出现一次
* 无返回值的纯虚函数，正确的写法是：virtual void fun() = 0;
 * 纯虚函数和虚函数的区别在于：纯虚函数有=0，虚函数没有。
 * 纯虚函数不可以有函数体，虚函数可以有函数体。
   * 纯虚函数的声明格式：virtual void fun() = 0;
   * 虚函数的声明格式：virtual void fun();
* 重载函数选择的依据：参数个数、参数类型、参数顺序
  * 函数的返回类型不是重载函数的依据
* int fun(int &a) 中的**&是引用符号，表示引用传递**。调用fun函数的时候只需要给他传递一个int类型的参数即可，而不是传递地址
* 抽象类不可以定义对象，但可以定义指针和引用
* 可以定义对象的类有 派生类、基类、嵌套类
* 类中定义的成员默认为私有的private
* 静态成员函数对类的数据成员访问时，**只允许是静态数据成员**
* 当将一个类A或者函数f()说明为另一个类B的友元后，类A或者函数f()能够直接访问类B的**具有任何访问权限**的成员
* 进行文件操作的时候应该包含的头文件是：**#include <fstream>**
  * math.h是数学函数库
  * strstrea.h是**字符串输入输出流函数库**
  * stdlib.h是**标准函数库**
  * string.h是字符串函数库
  * iostream是输入输出流函数库
  * hex的作用是**将其后面的变量的输出转换为十六进制**
  * 实现输出一个换行符并刷新流功能的操控符是**endl**
* cout实际上是cpp定义的对象名 **表示输出流对象**
* 从流中获取数据的操作称为**提取操作**
* 一般编译器给出的出错信息分为两种： **警告和错误**
* 将一个字符常量存放到内存单元时，实际上并不是把该字符本身放到内存单元中，而是将该字符相应的**ascii**代码存放到存储单元中
* 变量必须先**定义**，然后才能**使用**
* 在定义变量时，如果加上关键字**const**，那么变量的值在程序运行期间不能改变，这种变量称为**常变量**
* 循环结构中，要提前结束本次循环的语句有：**continue**
* 如果被调用函数的定义出现在主函数之后，需要对被调用的函数进行**声明**
* 定义内联函数所用的关键字是**inline**，定义有缘所用的关键字是friend
* 重载函数的参数顺序，参数数量，参数类型中至少要有一种不同
* 用于处理字符串的数据类型为**string**
* 函数参数传递方式有**传值**和**传地址**两种方式
* 变量分为全局和局部，**局部**没有赋初值，其值是不确定的
* 对于#define PI 3.14 如果要移除该宏定义，可以使用**#undef PI**
* 声明一个名为a的整形引用变量所使用的语句是：**int &a**
* 再用class定义一个类时，数据成员和成员函数的默认访问权限是private
* 使用**对象引用**作为函数参数，实参对象和形参对象代表同一对象，改变形参对象的值就是改变实参对象的值
* 当一个成员函数被调用时，系统自动向他传递一个隐含的参数，该参数是一个指向调用该函数的对象的指针，该指针的名字是**this**
* 声明一个常成员函数Fun，其返回类型为char，第一个参数类型为int，第二个参数类型为double，函数Fun的声明原型是：**char Fun(int, double) const**
* 当一个成员函数被调用时，该成员函数的**this指针**指向调用该函数的对象
* 定义对象时加关键字const，指定对象为**常对象**
* 一个const对象只能访问**const**成员函数
* 类和其他数据类型不同的是，组成这种类型的不仅可以有数据还可以有对数据进行操作的**成员函数**
* 调用构造函数和析构函数的顺序是：先构造的**后析构**，后构造的**先析构**
* 拷贝构造函数使用**引用**作为参数初始化创建中的对象
* 运算符[]只能用**成员**函数来重载，不能用友元函数来重载
* 重载赋值操作符时，运算符重载函数应声明为**成员函数**
* 重载的运算符仍保留原有的**优先级**和**结合性**和**操作符语法结构**
* 重载“=”运算符的函数名是：**operator=**
* 从一个或者多个以前定义的类产生新类的过程称为**派生**
* 类的继承是指子类继承基类的**数据成员**和**成员函数**
* 派生类的构造函数的一般形式中，通常应包含**基类构造函数**和**派生类构造函数**
* 在公有继承的情况下，积累的**保护成员**和**公有成员**在派生类中的访问权限不变\
* 派生类对基类继承方式有三种：**public、protected、private**
* 在保护派生中，基类权限为private的成员在派生类中的访问权限是**私有的**，**是不可访问的**
* 在cpp类中，有一种不能定义对象的类，这样的类只能被继承，称之为**抽象类**，定义该类至少具有一个**纯虚函数**
* 用**class virtual**声明的基类称为虚基类
* 带有纯虚函数的类称为抽象类，他只能作为**基类**来使用，不能定义对象
* 不同对象可以调用相同名称的函数，但可导致完全不同的行为的现象称为**多态**
* cpp语言支持两种多态性，分别是**静态多态性**和**动态多态性**
* 静态关联所支持的多态性称为**编译时**的多态性
* 动态关联要满足两个条件：**用指针或引用调用的成员函数**，**成员函数为虚函数**
* 动态关联是程序运行到需要的语句处才动态确定的，这称为**运行时**的多态性
* 用来表示变量、函数、类等名称的有效字符序列称为**标识符**
* 任何一个对象都应当两个要素：**属性**和**行为**
* 类是对象的**抽象**，对象是类的**具体化**
* 一个对象所占有的存储空间大小只取决于该对象**数据成员**所占的空间
* cpp专门设计了一个名为**this**的指针，用来指向不同的对象
* 诱问对象中的成员有三种方法：
  * **通过对象名和成员运算符访问**
  * **通过指向对象的指针访问**
  * **通过对象的引用访问**
* 通过成员函数对数据成员进行操作称为类的功能的**实现**
* 类中被操作的数据是私有的，类的功能的实现细节对用户是隐蔽的，这种实现称为**封装**也称为**私有实现**
* 类的**公用接口**和**私有实现**的分离形成了信息隐蔽
* 运算符重载的方法是定义一个重载运算符的**函数**
* 当实例化一个类时，如果该类的私有成员变量中有类，那先执行该类对应的构造函数，然后再执行实例化类的构造函数
* **count只能在类外进行初始化**
* 在类外用p.a的形式访问派生类对象p的基类成员a，其中a是公有继承的公有成员
* 类的析构函数不可以**有参数**也不可以**重载**
* **extern**关键字用于声明一个在其他文件中定义的全局变量或函数
* **需要加快程序执行速度**的情况下适合使用inline定义的内联函数
* double b=1+5e2;该语句中的e表示**10的幂**
  * 也就是说e的前面时一个数，后面时这个数的10的幂，后面也就是指数，指数必须是整数，不可以是小数
* 使用引用作为函数参数，是为了**实现函数之间数据的双向传递**
* 封装是指将**数据**和**对数据的操作**封装在一起，形成一个不可分割的整体
* 派生类中可以**继承基类成员**，也可以**重定义基类成员**
* 对于私有继承，基类成员的访问权限在派生类中全部变成**私有**的
* * ‘ ’表示**字符**，” ”表示____**字符串**____
* **静态**成员函数不能调用**非静态**成员函数
* 在面向对象的程序设计中，首先在问题域中识别出若干个**类**
* 相同类的模板的不同实例一般**没有**关系，而派生类各种类之间**有兄弟父子等**关系
* #include指令中的文件名可能含有**路径信息**
* 向量操作法中的front()函数是**返回向量的第一个元素**
* 重载的运算符保持其原有的**优先级**和**结合性**和**操作符语法结构**
* 编译时的多态性通过**重载**函数实现
* 预处理语句的种类：**宏定义、条件编译、文件包含**
* 控制格式输入输出的操作中，函数 **setw(int)** 是设置域宽的。
* vector的**back()方**法是返回向量的最后一个元素
* hex是**转换为十六进制**，oct是**转换为八进制**
* 在C++中要创建一个文件输入流对象fin，同时该对象打开文件“Test.txt”用于输入，则
  正确的声明语句是**ifstream fin(“Test.txt”);**
* 指针不调用**构造函数**
# * **_成员函数重载的运算符必须要好好复习！！！！！！！！！！！！！_**
# 访问派生类对象的基类成员的各种权限组合考问
* 要实现动态编联必须通过**对象指针或引用来调用虚函数**
* 17. 已知：p是一个指向类A数据成员m的指针，A1是类A的一个对象。如果要给m赋值为5，正确
      的是（）
      A. A1.p=5;
      B. A1->p=5;
      C. A1.*p=5;
      D. *A1.p=5;
        **答案：C**
* 如果采用动态多样性，要调用虚函数的是**基类对象指针**
* const char* const p="hellow";所定义的指针p和它所指向的内容**都不能**被修改
* 在构造函数和析构函数中调用虚函数时采用**静态联编**
* 静态数据成员属于**类**，不属于**对象**
* 如果要采用动态多样性，那么基类指针调用**虚函数**
* **构造函数**不能被派生类继承
* 自身类对象不能作为**类的成员**
* 派生类的构造函数的成员初始化列表中，不能包含**派生类对象的初始化**
* unsetf(ios::hex)表示**取消十六进制**
* 函数模板中紧随template之后见括号内的类型参数都要冠以保留字**typename**或者**class**
* 访问指针所指向的对象的成员使用 **->**运算符
* this指针始终指向调用成员函数的**当前对象**
* 派生类的主要用途时可以定义其基类的**当前对象**
* 派生类的主要用途是可以定义其基类中**没有的成员**或者**重写基类的成员**
* 类模板用来表达具有**相同处理方法**但**数据类型不同**的模板类对象集
* 如果通过同一个基类派生一系列的类，那么将这些类总称为**类层次结构**或者**继承层次结构**
* 所有模板都是以**template**关键字开始的
* 访问一个对象的成员所用的成员运算符是 **.**
* 定义**重载**函数时，应在参数个数或者参数类型上有所不同
* 在类中，如果不做特别说明，成员函数以及数据成员的默认访问权限是**私有**的，**而不是公有的**
* **构造函数**没有任何函数类型
* # 拷贝构造函数：
  * 如果一个类中没有定义拷贝构造函数的时候，系统将会**自动生成一个默认的**
  * 拷贝构造函数有**一**个参数，并且是该类对象的引用
  * 拷贝构造函数是一种**成员函数**
  * 拷贝构造函数的名字必须要和类的名字**一致**
  * 用赋值运算符 **“ = "** 将一个对象赋值给另一个同类对象的时候，**不会**调用拷贝初始化构造函数
  * **自身类的对象**是不可以做为某类的成员的
  * 具有转换函数功能的构造函数应该是带有**一个参数**的构造函数
* 静态数据成员在类内进行**声明**，在类外进行**定义和初始化**
  * 定义静态成员函数的主要目的是**处理类的静态成员变量**
  * 静态数据成员的主要作用是**共享数据**和**节省内存空间**，而不是**提高程序的运行速度**。
* 友元函数**破坏了**类的封装性和隐藏性
  * 构造函数可以声明为**友元**
  * 友元函数不是**成员函数**，所以他没有**this指针**
  * 友元函数通过**参数**传递对象，而不是用**this指针**访问对象成员
  * this指针是**类的成员函数**特有的，用于指向**调用该成员函数的对象**
  * 友元函数与**数据类型**无关，主要用于访问类的**私有成员**，无法实现**逻辑功能相同但数据类型不同的需求**
* 假定AA是一个类，“AA* abc()const;”是该类中一个成员函数的原型，若该函数返回this值，当用x.abc()调用该成员函数后，x的值（ ）。
A. 已经被改变
B. 可能被改变
C. 不变
D. 受到函数调用的影响
* class person{ 
    int num;
    char name[10];
    public:
    void init(int n, char *m);
    ...
  };
person std[30];  
  * 对于类型为类的数组来说，**成员变量**是每个对象独立拥有的，但是**成员函数**是所有对象共享的
* 对于涉及动态内存分配的类T，不必重载的运算符有**&、*、->、[]、sizeof、typeid、::、?:**
* 派生类继承基类的时候，如果省略继承方式，那默认为**私有继承**
* 解决二义性最常用的方法是**作用域运算符对成员进行限定**
* 多重继承是指**一个派生类从多个基类继承**。这种情况下可能会出现**二义性**
  * 当派生类和基类中出现同名函数时，**派生类**的函数会**隐藏基类的同名函数**，并不会导致**二义性**。
  * 要访问基类的同名函数，可以使用作用域运算符 **::** 来限定
  * 在如下继承层次下，当实例化有派生类对象时，调用构造函数的顺序为（ **D** ）。
    class Base{…};
    class Base1: virtual Base{…};
    class Base2: virtual Base{…};
    class Derived : public Base2, public Base1{…};
    A.  Base(), Base1(), Base(), Base2(), Drived()
    B.  Base(), Base2(), Base(), Base1(), Drived()
    C.  Base(), Base1(), Base2(), Drived()
    D.  Base(), Base2(), Base1(), Drived()
  * 先调用**基类**的构造函数，再按照从**基类**到**派生类**的顺序，依次调用**直接基类**的构造函数，最后调用**派生类**的构造函数**
* 子类以**protected**形式继承基类后，**子类内部**可以继续调用基类的**protected**成员以及**public**成员，但是**子类的对象**不可以调用基类的**protected**成员以及**public**成员
  * 派生类可以定义与基类**同名的成员**，但会**隐藏基类的同名成员**(无论是成员函数还是数据成员)
  * 派生类对象可以用**基类指针指向**，向上转型是安全的 
  * 基类对象不能**赋值给派生类指针**，向下转型不安全
   * 也就是说可以把派生类的对象赋给**基类的指针**，但是不能把基类的对象赋给**派生类的指针**：如：Base *p = new Derived; or Drived d; Base &p = d; 
* 如果基类是**虚继承**的，那么无论创建多少个派生类对象，基类的构造函数只会执行一次
* 如果基类是 **普通继承(非虚继承)** 时，每个派生类对象实例化的时候都会调用基类的构造函数，不管有多少个派生类对象，每个对象都会调用一次基类构造函数
* 类模板的使用实际上是将类模板实例化成一个具体的**类**
  * 函数博班的实例化通常是由**编译器自动完成的**，不是由**程序员手动实例化**完成
  * 一个类定义中，**只要**有**一**个函数模板，那么这个类就是**类模板**
  * 类模板的成员函数都是**函数模板**，类模板实例化后，成员函数也随之**实例化**
  * cpp有隐式转换的功能，可以做到将**float**类型的变量的值赋给**int**类型的变量
  * 类模板参数可以作为**数据成员**的类型，也可以作为成**成员函数**的返回类型，也可以作为**成员函数的参数类型**
  * cpp模板关键字是**class**或者**typename**，而不是**Class**
  * 模板的参数列表可以**省略参数名称**，但不可以**省略参数类型**
  * 模板类和类模板的区分：
    * 类模板是**定义一种模板**，可以**用不同的数据类型来实例化具体的类**
    * 而模板类是**对类模板实例化出的具体类**
  * 函数模板的实例化由**编译器**实现，而类模板的实例化由**程序员**实现
  * 普通基类可以作为**类模板**的基类
  * 类模板从**普通类**派生，也可以从**类模板**派生
  * 根据建立对象时的实际数据类型，编译器把类模板实例化为**模板类**
  * 函数的类模板参数需要通过**构造函数实例化**
  * 宏函数、函数重载、模板 都可以实现**逻辑功能相同**但**数据类型不同**的需求
#### 输入输出流概念
* **get()** 函数不会自动跳过分隔符，他会逐字符读取直到遇到分隔符为止
* **getline()** 函数确实可以读取一行文本，但是他会自动跳过分隔符
* 输出流通常用于将**内存中**的数据写入**外部设备或者文件**，并不是从**文件**读取数据并显示到**屏幕**上
* **输入流**通常用于从文件读取数据，**输出流**负责将数据显示到屏幕上
* 流表示了信息从源到目的端的流动，数据按顺序从一个对象传送到另一个对象
* 流中的内容可以是**ASCII字符**，**二进制形式的数据**，**数字音频视频**或者**其他形式**的信息
* **数据被装配成字节流**，无论什么格式的数据流都认为是**由若干字节组成的字节序列**
* cout用于将数据从**内存传到标准输出设备**，但并非只能传送到标准输出设备，也可以通过**重定向**传输到其他设备
* cerr和clog都是标准错误流对象，但是cerr是**无缓冲**的，而clog是**有缓冲**的
* cin是标准输入流对象，但他负责的是将数据从**标准输入设备**传到**内存**，不是从**内存**流向**标准输入设备**
* istream类中能够实现输入字符串的成员函数为：**getline()**，**get()**，**read()**
* **read()** 是输入操作的成员函数，用于从输入流中读取指定数量的字符
* 运算符<<和>>可以通过**对其进行重载，对类对象进行输入输出操作**
  * <<和>>**默认不支持用户自定义类型**的数据进行输入与输出操作，需要重载
  * <<和>>可以通过**重载支持用户自定义类型**
  * <<和>>**默认支持基本类型的数据**进行输入输出操作
* 文件流ofstream对象默认的打开方式为 **ios::out|ios::trunc**
* 文本文件与二进制文件：
  * 在**文本**模式里，任何数据都被解释为一系列的**字符**
  * 文本文件读写数据的时候，内存中存储的二进制数据需要**转换为字符**的形式
  * **二进制**文件督学数据的时候，无需进行格式的转换，流中直接传送原始字节数据
  * **文本文件**读写文件效率很低，不适合大规模的数据存传输
  * 可以使用成员函数**istream&istream::seekg()** 将**文件指针**指向文件中某个位置
  * 二进制文件和文本文件都可以实现**随机读写**
  * ostream::teeg()用于获取**文件指针的位置**
* 定义包含纯虚函数的虚类之后，继承基类得到的派生类中对虚类的重新定义叫重写 要使用override关键字  void speak() override{}
* 虚类对派生类的实例化要先对虚类实例化一个指针，要用指针符号  比如： Animal * a; a->Dog;
* 使用指针类调用对应函数的时候要使用->符号
* outfile.write((char*) &data, sizeof(float));
  * 它获取了 data 的地址，并将其转换为 char* 类型，以便逐字节地访问 data 的二进制内容。
  * 它告诉 write 方法需要写入 sizeof(float) 字节的数据。
* 在创建派生类对象的时候，构造函数的执行顺序是：基类构造函数、对象成员构造函数、派生本身的构造函数
* 枚举类型的成员如果没有显式赋值，它们会自动按顺序递增
  * 第一个枚举成员如果没有指定值，则默认为0。
  * 后续的每个成员如果没有指定值，则它的值是前一个成员的值加1。
* 指针只是指针，不管其类型是基础类型还是类类型，他都不是一个对象，不能用它直接调用类的成员函数，必须要将其指向一个类的对象，然后才可以调用该对象对应类的函数
* 类的友元函数可以访问类中的私有成员
  * 指向基类的指针可以指向派生类的对象
* 派生类的构造函数的成员初始化列表中，不能包含**基类中成员对象的初始化**，可以包含**基类构造函数**、派生类中成员对象的初始化，派生类中一般数据成员的初始化
* sizeof()表示**数据类型**或者**变量**所占的**字节数**
  * 比如int a[3][4]; 那么表达式sizeof(a)的值是**48**,它代表了数组a的所有元素的字节数，sizeof(int[4])表示一个数组有四个元素，然后得到该四个元素的字节总数为16
  * 有定义int a[2][3]={{1,2,3},{4,5,6}}, *p=a[1];那么表达式p[2]的值为6
    * 因为a[1]代表的是第二行，那么p指向后就默认第二行开始，所以p[2]就是第二行的第三个元素
* “dsa\0dasd”只输出dsa，因为\0是字符串结束符，不管后面还有什么都不输出
 * 静态全局变量的作用域是**定义该静态全局变量的文件内部** 
 * cin.get()读入一个字符并返回他的值
   * cin.getline()读入一行字符并返回他的值
   * cin.ignore()忽略输入流中的字符
   * cin.putback()将字符放回输入流
   * cin.peek()检查下一个输入的字符，不会把字符从流中移除
   * cin.clear()清除错误标志
 * 重载、重写、重定义
   * 重载：**用同一个函数名定义不同的函数**，但是函数名和不同参数搭配时函数含义不同。比如构造函数
        * 规则：函数名相同，参数不同，仅仅只有返回值类型不同那么不可以构成重载
   * 重写：(覆盖)指派生类和函数**覆盖**了与其同名的基类函数
        * 规则：不同的范围，分别位于基类与派生类中。函数名字相同 参数相同基类函数必须要有virtual关键字
   * 重定义：(自动)指派生类和函数屏蔽了与其同名的基类函数
        * 如果派生类的函数和基类的函数同名，但是参数不同，此时不管有无virtual，基类和函数被隐藏
          如果派生类的函数与基类函数同名，并且参数也一样，但是基类函数没有virtual关键字，此时基类的函数也被隐藏了
* 给指针赋地址的时候必须要赋予与其相对应的类型的地址，比如int类型的指针只能给他赋予int类型的地址
  * 当你声明一个指向数组的指针时，比如 int *p = y; （假设 y 是一个整型数组），这个指针 p 实际上保存的是数组 y 的第一个元素（即 y[0]）的地址，也就是数组的首地址
  * 指针pnew了一个类对象，那么他最后也要调用析构函数
* 构造函数可以是内联函数
* 重载运算符
  * 重载运算符只能改变现有运算符的行为，不能创造新的运算符
  * 重载运算符不仅仅可以通过**成员函数**重载，也可以通过**友元函数**重载
  * 运算符可以重载为友元函数或者成员函数
  * 当以**成员函数**形式重载二元运算符的时候，**只需要声明一个参数**，因为隐含的this指针已经提供了第一个参数
  * 若以**非成员函数**(友元函数)的形式重载二元运算符，那么**需要两个参数**
* 运算符
  * ！是逻辑非运算符，任何非零值都被视作true，0被视作false，所以-1被视作true
  * ![img.png](img.png)
  * 逗号运算符用于以此计算多个表达式，但是只返回最后一个表达式的值
    * 当 运算符的左操作数不是类对象，或者需要访问类的私有成员 时，必须使用 friend。
      * 比如以下代码：
      * 
    class ss{
    private:
    int id;
    string name;
    double cg;
    double eg;
    double mg;
    public:
    ss(){
    }
            ss(int a, string b, double c, double d, double e):id(a),name(b),cg(c),eg(d),mg(e){
            }
          
            void print(){
                cout<<"id："<<id<<",name:"<<name<<",cg:"<<cg<<",eg:"<<eg<<",mg:"<<mg<<endl;
            }
            void sum(){
                cout<<"sum="<<cg+eg+mg<<endl;
            }
            void avg(){
                cout<<"avg="<<(cg+eg+mg)/2<<endl;
            }
            friend ostream& operator<<(ostream &os, const ss &a){
                cout<<"id:"<<a.id<<",name"<<a.name<<endl;
                os<<"c++score:"<<a.cg<<endl;
                return os;
            }
  
    };
    int main(){
    ss a(1,"aa", 2, 4, 55);
    a.print();
    cout<<a<<endl;
    return 0;
    }










