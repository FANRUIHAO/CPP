* 声明A类的函数f()为友元函数的操作：
	**friend void A::f();**
* 返回查找到的字符串所在主串的位置的方法：
	**indexOf()**
* 设置填充字符的函数：
	**setfill(char)**
* cpp的多态性分为**编译时的多态性和运行时的多态性**
* cout<<str.substr(5，3)指的是**输出变量str的下标为5开始之后三个字符**
* setw()用于**设置输出的宽度**
	* 例如：
		* int m=22
		* cout<<setw(5)<<m;
	* 输出结果为：   22
	* (22前面空三个间距)
* strcpy 函数的作用是**将第二个参数指向的字符串复制到第一个参数指向的内存位置。**
* strcat 函数的作用是**将第二个参数指向的字符串追加到第一个参数指向的字符串的末尾。**
* main函数里每次新建对象时先调用**基类构造函数然**后再调用**继承类构造函数**，等待所有代码运行完后**依次调用继承类的析构函数和基类的析构函数**
* "\n"等价于**endl**
_* 拷贝构造函数的函数名必须**与类名相同**，并且参数类型必须是**类名的引用**_
* operator 关键字用于**定义或重载运算符**。运算符重载允许用户为自定义类型（如类或结构体）定义特定的运算符行为，使其能够像内置类型一样使用运算符。
* 由cpp源程序文件编译而成的目标代码文件的缺省扩展名为  **obj**
* cpp基本数据类型：
  * **整型、浮点型、字符型、布尔类型**
* cpp构造类型
  * **枚举型，数组行，结构体类型，共用体类型，类类型**
* 前缀Ox是用于**标识十六进制前缀或后缀**
* 当一个或两个操作数是浮点数时，结果是**一个浮点数**
* #include指令有两种形式
  * #include <file>：这种形式用于包含**标准库头文件或系统头文件**
  * #include "file"：这种形式用于包含**用户自定义的头文件**
* 引用格式 **int &a = b;**
  * a是b的引用，a和b指向同一个地址，a的值改变b的值**也会改变**
* 函数原型的参数部分可以只包含**参数类型**，而不需要包含**参数名称**
* 形参是实参的副本，**形参的改变不会影响实参**
* 可以声明为内联函数的函数包括：**构造函数、析构函数、成员函数**
* 包含**循环语句**的函数不能声明为内联函数
* 函数声明时，必须要声明**函数名、函数类型、参数名、参数类型**
* 设置参数默认值时，先设置右边的参数默认值，再设置左边的参数默认值
* 默认参数必须放在参数序列的后部，也就是右侧
* 重载函数的参数列表必须不同，参数个数不同或者参数类型不同
* 定义模板中使用的参数类型标识符需要使用符号<>括起来
* 类中定义的成员，其隐含访问权限是private
* cpp允许在结构中定义的函数称为  成员函数
* 使用delete删除对象数组时，数组中各元素都调用析构函数
* 在类中，如果不做特别说明，所有的成员函数均为 private
* 面向对象关键要素：封装、继承、多态、抽象
* 类的常成员函数表示法：void fun() const;
* 如果没有使用private关键字定义类的数据成员，那么默认为private
* this指针存在的目的是：保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码
* 构造函数有且只有一个
* 构造函数不必指定类型说明
* 拷贝构造函数的参数是某个对象的引用名
* 析构函数不能指定返回类型
* 静态数据成员是类的所有对象共享的数据成员
  * 静态数据成员是所有对象共享的，这意味着无论创建多少个类的对象，它们都共享同一个静态数据成员。对静态数据成员的任何操作都会影响所有对象，因为它们都引用同一个变量
* 初始化类的静态整型成员的语法格式：
  * int A::x = 0;
* 任何类或者函数都可以作为友元
* 友元不是本类的成员函数，但是可以访问本类的私有成员
* 如果类A被说明成类B的友元，那么类B不一定是类A的友元
* 继承的机制是定义新类    可以使用现有类的所有成员，而不需要重新编写这些成员
* 基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以访问这些成员
* 在公有继承种，基类中的**保护成员**作为派生类的**保护成员**，基类中的**公有成员**作为派生类的**公有成员**
* **构造函数**不能被派生类继承
* 在**public、protected、private**派生方式中，派生类可以访问基类中的protected成员
* 继承中，派生类拥有的基类个数最少要有一个。
  * 派生类可以继承多个基类，这种继承方式称为**多重继承**
* 私有派生时，基类的所有成员访问权限在派生类中都是**私有的**
* 如果一个类至少有一个纯虚函数，那么就称该类为**抽象类**
* 设置虚基类（virtual）的目的是为了解决多重继承时的二义性问题
  * 虚基类可以使得共同的基类在派生类中只出现一次
* 无返回值的纯虚函数，正确的写法是：virtual void fun() = 0;
 * 纯虚函数和虚函数的区别在于：纯虚函数有=0，虚函数没有。
 * 纯虚函数不可以有函数体，虚函数可以有函数体。
   * 纯虚函数的声明格式：virtual void fun() = 0;
   * 虚函数的声明格式：virtual void fun();
* 重载函数选择的依据：参数个数、参数类型、参数顺序
  * 函数的返回类型不是重载函数的依据
* int fun(int &a) 中的**&是引用符号，表示引用传递**。调用fun函数的时候只需要给他传递一个int类型的参数即可，而不是传递地址
* 抽象类不可以定义对象，但可以定义指针和引用
* 可以定义对象的类有 派生类、基类、嵌套类
* 类中定义的成员默认为私有的private
* 静态成员函数对类的数据成员访问时，**只允许是静态数据成员**
* 当将一个类A或者函数f()说明为另一个类B的友元后，类A或者函数f()能够直接访问类B的**具有任何访问权限**的成员
* 进行文件操作的时候应该包含的头文件是：**#include <fstream>**
  * math.h是数学函数库
  * strstrea.h是**字符串输入输出流函数库**
  * stdlib.h是**标准函数库**
  * string.h是字符串函数库
  * iostream是输入输出流函数库
  * hex的作用是**将其后面的变量的输出转换为十六进制**
  * 实现输出一个换行符并刷新流功能的操控符是**endl**
* cout实际上是cpp定义的对象名 **表示输出流对象**
* 从流中获取数据的操作称为**提取操作**
* 一般编译器给出的出错信息分为两种： **警告和错误**
* 将一个字符常量存放到内存单元时，实际上并不是把该字符本身放到内存单元中，而是将该字符相应的**ascii**代码存放到存储单元中
* 变量必须先**定义**，然后才能**使用**
* 在定义变量时，如果加上关键字**const**，那么变量的值在程序运行期间不能改变，这种变量称为**常变量**
* 循环结构中，要提前结束本次循环的语句有：**continue**
* 如果被调用函数的定义出现在主函数之后，需要对被调用的函数进行**声明**
* 定义内联函数所用的关键字是**inline**，定义有缘所用的关键字是friend
* 重载函数的参数顺序，参数数量，参数类型中至少要有一种不同
* 用于处理字符串的数据类型为**string**
* 函数参数传递方式有**传值**和**传地址**两种方式
* 变量分为全局和局部，**局部**没有赋初值，其值是不确定的
* 对于#define PI 3.14 如果要移除该宏定义，可以使用**#undef PI**
* 声明一个名为a的整形引用变量所使用的语句是：**int &a**
* 再用class定义一个类时，数据成员和成员函数的默认访问权限是private
* 使用**对象引用**作为函数参数，实参对象和形参对象代表同一对象，改变形参对象的值就是改变实参对象的值
* 当一个成员函数被调用时，系统自动向他传递一个隐含的参数，该参数是一个指向调用该函数的对象的指针，该指针的名字是**this**
* 声明一个常成员函数Fun，其返回类型为char，第一个参数类型为int，第二个参数类型为double，函数Fun的声明原型是：**char Fun(int, double) const**
* 当一个成员函数被调用时，该成员函数的**this指针**指向调用该函数的对象
* 定义对象时加关键字const，指定对象为**常对象**
* 一个const对象只能访问**const**成员函数
* 类和其他数据类型不同的是，组成这种类型的不仅可以有数据还可以有对数据进行操作的**成员函数**
* 调用构造函数和析构函数的顺序是：先构造的**后析构**，后构造的**先析构**
* 拷贝构造函数使用**引用**作为参数初始化创建中的对象
* 运算符[]只能用**成员**函数来重载，不能用友元函数来重载
* 重载赋值操作符时，运算符重载函数应声明为**成员函数**
* 重载的运算符仍保留原有的**优先级**和**结合性**和**操作符语法结构**
* 重载“=”运算符的函数名是：**operator=**
* 从一个或者多个以前定义的类产生新类的过程称为**派生**
* 类的继承是指子类继承基类的**数据成员**和**成员函数**
* 派生类的构造函数的一般形式中，通常应包含**基类构造函数**和**派生类构造函数**
* 在公有继承的情况下，积累的**保护成员**和**公有成员**在派生类中的访问权限不变\
* 派生类对基类继承方式有三种：**public、protected、private**
* 在保护派生中，基类权限为private的成员在派生类中的访问权限是**私有的**，**是不可访问的**
* 在cpp类中，有一种不能定义对象的类，这样的类只能被继承，称之为**抽象类**，定义该类至少具有一个**纯虚函数**
* 用**class virtual**声明的基类称为虚基类
* 带有纯虚函数的类称为抽象类，他只能作为**基类**来使用，不能定义对象
* 不同对象可以调用相同名称的函数，但可导致完全不同的行为的现象称为**多态**
* cpp语言支持两种多态性，分别是**静态多态性**和**动态多态性**
* 静态关联所支持的多态性称为**编译时**的多态性
* 动态关联要满足两个条件：**用指针或引用调用的成员函数**，**成员函数为虚函数**
* 动态关联是程序运行到需要的语句处才动态确定的，这称为**运行时**的多态性
* 用来表示变量、函数、类等名称的有效字符序列称为**标识符**
* 任何一个对象都应当两个要素：**属性**和**行为**
* 类是对象的**抽象**，对象是类的**具体化**
* 一个对象所占有的存储空间大小只取决于该对象**数据成员**所占的空间
* cpp专门设计了一个名为**this**的指针，用来指向不同的对象
* 诱问对象中的成员有三种方法：
  * **通过对象名和成员运算符访问**
  * **通过指向对象的指针访问**
  * **通过对象的引用访问**
* 通过成员函数对数据成员进行操作称为类的功能的**实现**
* 类中被操作的数据是私有的，类的功能的实现细节对用户是隐蔽的，这种实现称为**封装**也称为**私有实现**
* 类的**公用接口**和**私有实现**的分离形成了信息隐蔽
* 运算符重载的方法是定义一个重载运算符的**函数**
* 当实例化一个类时，如果该类的私有成员变量中有类，那先执行该类对应的构造函数，然后再执行实例化类的构造函数
* **count只能在类外进行初始化**
* 在类外用p.a的形式访问派生类对象p的基类成员a，其中a是公有继承的公有成员
* 类的析构函数不可以**有参数**也不可以**重载**
* **extern**关键字用于声明一个在其他文件中定义的全局变量或函数
* **需要加快程序执行速度**的情况下适合使用inline定义的内联函数
* double b=1+5e2;该语句中的e表示**10的幂**
  * 也就是说e的前面时一个数，后面时这个数的10的幂，后面也就是指数，指数必须是整数，不可以是小数
* 使用引用作为函数参数，是为了**实现函数之间数据的双向传递**
* 封装是指将**数据**和**对数据的操作**封装在一起，形成一个不可分割的整体
* 派生类中可以**继承基类成员**，也可以**重定义基类成员**
* 对于私有继承，基类成员的访问权限在派生类中全部变成私有的
* 静态成员函数不能调用非静态成员函数
* 在面向对象的程序设计中，首先在问题域中识别出若干个类
* 相同类的模板的不同实力一般没有关系，而派生类各种类之间有兄弟父子等关系
* #include指令中的文件名可能含有路径信息
* 向量操作法中的front()函数是返回向量的第一个元素
* 重载的运算符保持其原有的**优先级**和**结合性**和**操作符语法结构**
* 编译时的多态性通过**重载**函数实现
* 预处理语句的种类：**宏定义、条件编译、文件包含**
* 控制格式输入输出的操作中，函数**setw(int)**是设置域宽的。
* vector的**back()方**法是返回向量的最后一个元素
* hex是转换为十六进制，oct是转换为八进制
* 在C++中要创建一个文件输入流对象fin，同时该对象打开文件“Test.txt”用于输入，则
  正确的声明语句是**ifstream fin(“Test.txt”);**
* 指针不调用构造函数
# * **_成员函数重载的运算符必须要好好复习！！！！！！！！！！！！！_**
# 访问派生类对象的基类成员的各种权限组合考问
* 要实现动态编联必须通过**对象指针或引用来调用虚函数**
* 17. 已知：p是一个指向类A数据成员m的指针，A1是类A的一个对象。如果要给m赋值为5，正确
      的是（）
      A. A1.p=5;
      B. A1->p=5;
      C. A1.*p=5;
      D. *A1.p=5;
        **答案：C**
* 如果采用动态多样性，要调用虚函数的是基类对象指针
* const char* const p="hellow";所定义的指针p和它所指向的内容都不能被修改
* 在构造函数和析构函数中调用虚函数时采用**静态联编**
* 静态数据成员属于类，不属于对象
* 如果要采用动态多样性，那么基类指针调用虚函数
* **构造函数**不能被派生类继承
* 自身类对象不能作为类的成员
* 派生类的构造函数的成员初始化列表中，不能包含**派生类对象的初始化**
* unsetf(ios::hex)表示取消十六进制
* 函数模板中紧随template之后见括号内的类型参数都要冠以保留字typename或者class
* 访问指针所指向的对象的成员使用->运算符
* this指针始终指向调用成员函数的**当前对象**
* 派生类的主要用途时可以定义其基类的**当前对象**
* 派生类的主要用途是可以定义其基类中没有的成员或者重写基类的成员
* 类模板用来表达具有相同处理方法但数据类型不同的模板类对象集
* 如果通过同一个基类派生一系列的类，那么将这些类总称为类层次结构或者继承层次结构
* 所有模板都是以template关键字开始的
* 访问一个对象的成员所用的成员运算符是 **.**
* 定义**重载**函数时，应在参数个数或者参数类型上有所不同
























